# Case-study оптимизации

## Актуальная проблемы
A. Импорт данных
При выполнении bin/setup в базу данных загружаются данные о рейсах из файла fixtures/small.json
Сама загрузка данных из файла делается очень наивно (и не эффективно).
В комплекте с заданием поставляются файлы
Нужно оптимизировать механизм перезагрузки расписания из файла так, чтобы он импортировал файл large.json в пределах минуты.
rake reload_json[fixtures/large.json]

Б. Отображение расписаний
Сами страницы расписаний тоже формируются не эффективно и при росте объёмов начинают сильно тормозить.
Нужно найти и устранить проблемы, замедляющие формирование этих страниц.

## Часть А

### Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время импорта файла large.json в секундах

### Гарантия корректности работы оптимизированной программы
Для проверки корректной работы программе в начале я написал тест. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.
Дополнительно в тест я добавил защиту от регрессии времени работы программы, обновляя значение после каждого шага

### Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за ~ 10 секунд

Вот как я построил `feedback_loop`:
Для начала я взял файл small.json
- Прогоняется тест корректности работы и производительности
- Выполняется профилирование
- По результатам профилирования ищется главная точка роста
- Вносятся правки в код, прогоняются тесты, если тесты не упали и точка роста поменялась то апдейчу тесты и ищу новую точку роста

### Вникаем в детали системы, чтобы найти главные точки роста
Вот какие проблемы удалось найти и решить

#### Ваша находка №1
- Согласно плану работы сначала было решено использовать activerecord-import для импорта файлов
- Я переделал процесс импорта файла, теперь поездки сохраняются с помощью activerecord-import. Кроме того, я сделал накапливание айдишников объектов, чтобы убрать лишние обращения к базе.
- 6.1 секунд -> 2.5 секунды для файла small.json. medium.json 6.1 секунды, large.json 23 секунды.
- В целом уже удалось уложиться в бюджет, но для интереса можно попрофилировать

### Ваша находка №2
- Рубипроф и мемори профайлер выдавали нечитаемые отчеты из-за запуска таски в енвайронменте рельсов. Я решил попробовать сократить использование памяти
- Вместо того чтобы собирать объекты через Trip.new в отдельный массив, я использую map при пробеге по джсону чтобы собрать аргументы и затем использользовать их для импорта
- 23 секунды -> 15 секунд для файла large.json
- В бюджет укладываемся с запасом

## Часть Б

### Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время загрузки страницы в миллисекундах

#### Ваша находка №1
- Bullet ругается на N+1 запросы 
- Добавим инклюдсов `Trip.includes(bus: %w[services buses_services])`
- 10242ms -> 5800ms
- Bullet больше не ругается на N+1 запросы, при этом `ActiveRecord: 31.8ms` намекает на то что запросы можно больше не оптимизировать

### Ваша находка №2
- rack-mini-profiler показывает что много времени уходит на рендеринг паршалов
- Уберем лишние паршалы, разделитель можно не рендерить отдельно а передать как параметр рендеринга коллекции `<%= render partial: 'trip', collection: @trips, spacer_template: "delimiter" %>`
- 5800ms -> 1482ms
- Загрузка страницы за полторы секунды -- приемлимо, но в учебных целях можно посмотреть что еще есть оптимизировать

### Ваша находка №3
- по pghero виден лишний запрос для получения количества поездок
- Заменим `@trips.count` на `@trips.size`
- время загрузки не поменялось
- один запрос на производительность особо не влиял. Pghero больше ничего интересного не показывает
