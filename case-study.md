### 1. Оптимизация загрузки данных в базу приложения

#### Проблема 
Рейк-таск для загрузки данных в базу приложения работает слишком долго: ~8 секунд для файла с 1_000 записей, ~67 секунд для файла с 10_000 записей. 

#### Метрика
Чтобы понять, несут ли изменения положительный эффект, в качестве метрики выбрано время загрузки файлов поставляемых с программой. Также в процессе оптимизации планирую следить за потреблением памяти.

#### Гарантия корректности работы программы
Для гарантии корректной работы написан тест проверяющий что в базу корректно загружается файл `fixtures/example.json`

#### Feedback-loop
Для получения быстрой обратной связи добавлены скрипты генерации отчетов профилировщиков.

#### Процесс оптимизации
В исходном состоянии скрипт загрузки имеет следующие показатели для файла small.json (1к записей, размер ~304K)
Потребление памяти (вместе со всем rails приложением)
```
Total allocated: 467.01 MB (4716422 objects)
Total retained:  10.68 MB (9833 objects)
```
Время работы - ~9 сек

Ruby-prof по времени не показал точек роста - отчет в основном состоит из внутренностей Rails.

Собрал лог из базы данных и скормил его pgbadger - оказалось что для вставки 1_000 записей выполняется 13_528 запросов к базе.  
Из них 68% (9_253) это SELECT, т.е. даже не вставка данных. Несложно было догадаться что основная масса из них это проверка "справочников" и валидации AR выполняемые при сохранении данных.  
Решил сделать как было предложено в подсказках к заданию - использовать гем `activerecord-import` а также собрать справочники и загрузить их одной пачкой.

Благодаря этим действиям удалось значительно снизить время загрузки данных :  
Без AR валидаций small.json - ~1.1 секунд, large.json - ~7.7 секунд  
С AR валидациями small.json - ~1.3 секунд, large.json - ~18.4 секунд  
(данные, включая время старта окружения)

Потребление памяти также сократилось:   
small.json:
```
Total allocated: 24.79 MB (159304 objects)
Total retained:  10.61 MB (9125 objects)
```
large.json
```
Total allocated: 710.76 MB (5513967 objects)
Total retained:  10.61 MB (9120 objects)
```
Естественно что без стриминга мы грузим в память файл который обрабатываем целиком, но bonus часть я не выполнял, так что оставляю как есть.

#### Результат
В результате проведенной оптимизации удалось уложиться в рамки задачи.

#### Защита от регрессии
Для защиты от регрессии добавлен тест, который проверяет время загрузки файла с 1к записей.


### 2. Оптимизация времени загрузки страницы

#### Проблема 
Страница с расписанием автобусов загружается слишком долго.

#### Метрика
Чтобы понять, несут ли изменения положительный эффект, в качестве метрики выбрано время загрузки страницы для файла large.json.

#### Гарантия корректности работы программы
Для гарантии корректной работы написан тест проверяющий что контроллер выдает корректный html для файла `example.json`

#### Feedback-loop
Профилировщики выдают отчеты прямо на оптимизируемой странице.

#### Процесс оптимизации
Перед оптимизацией страница загружалась за ~15-19 секунд для файла large.json.  

Rails-panel и rack mini profiler показали что основная масса времени тратится на рендеринг.
Решил собрать все темплейты в один файл, поскольку они очень простые.  
В результате время загрузки страницы почти не изменилось.

И оба профайлера выше и логи показали что страница делает ~2000 запросов в базу, прямо из вьюх (видимо поэтому rails panel отнес все затраты времени в рендеринг)  
Уменьшил количество запросов к базе поправив N+2 (заюзал `includes`), и сделал принудительную загрузку данных в контроллере (`.to_a` на запросе)  
Стало 6 запросов к базе, время загрузки сократилось значительно - до ~450-500 ms. Плюс стало четко видно сколько времени занимает непосредственно рендеринг - ~80-120ms

Добавил индексов на id поля, но pg_hero поругал меня за дубликаты, пришлось удалить :)

#### Результат
В результате проведенной оптимизации удалось уложиться в рамки задачи (~500ms)?

#### Защита от регрессии
Для защиты от регрессии добавил тест, который проверяет время ответа контроллера. К сожалению время ответа очень сильно различается от теста к тесту, поэтому с запасом указал 0.5 сек для файла example.json

#### P.S. 
Понимаю, что нет предела совершенству - можно и "справочники" превратить в константы, и кеширование добавить во вьюхи и пагинацию на страницы, но устал :)
