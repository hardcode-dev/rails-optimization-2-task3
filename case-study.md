# Case-study оптимизации

## Актуальная проблема

В нашем проекте возникла серьёзная проблема.

Страница расписаний формируется не эффективно, механизм перезагрузки расписаний из файла занимает очень много времени(больше минуты)

## Задачи

### №1 Сократить время выполнения импорта данных

### №2 Оптимизировать загрузку отображения расписаний

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время исполнения rake таски и страницы с рейсами

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался:

- pghero
- rack-mini-profiler
- memory-profiler
- bullet
- rspec-benchmark
- rspec-sqlimit

### Шаг №0

Прогнал rake reload_json для всех файлов в fixtures, записал результаты
large.json отрабатывал слишком долго, не стал ждать
Буду ориентироваться на small.json, результат: 30 секунд

Решил сразу воспользоваться советом использовать гем `activerecord-import`

Поставил его, применил для импорта Trip
После прогона make reload_small время работы сократилось и составило 26 сек

### Шаг №1

В этом шаге решил сконцентрироваться на загрузке данных из json в базу

#### Подготовка:

Добавил в проект
- pghero
- rack-mini-profiler
- memory-profiler
- bullet
- rspec-benchmark
- rspec-sqlimit

Перенес код по импорту данных из rake task в отдельный интерактор `ImportData`

Для того, чтобы лучше разобраться в коде и защитить его, написал rspec тесты и сделал рефакторинг

#### Профилирование:

С помощью тестов `rspec-sqlimit` смог увидеть количество запросов, которые я делаю в базу

Как оказалось, использовать `activerecord-import` только лишь для Trip было не так корректно, так как к другим таблицам все равно было очень много запросов.

#### Изменения:

Сделал хранение всей информации в хеше. Это позволит нам не делать так много запросов SELECT к базе, чтобы найти запись.

Использовал метод `import` из гема `activerecord-import` для других моделей:
Service, Bus, City

#### Результаты:

Импорт данных:
|                  |ДО                        |ПОСЛЕ                     |
|------------------|--------------------------|--------------------------|
| example.json     | 0.547757 сек             | 0.257931 сек             |
| large.json       | очень долго              | 56 сек                   |
| medium.json      | 229 сек                  | 10 сек                   |
| small.json       | 30 сек                   | 2.990186 сек             |

#### Выводы:

Нагрузка на память выросла за счет того, что все данные стали хранится в хешах(MEMORY USAGE: 1067 MB)
Но я смог сократить время работы за счет уменьшения количества запросов в базу.
Так что по метрике задача №1 была выполнена

Думаю, что можно сократить и показатели по памяти, но тогда нужно будет отказаться от `activerecord-import` и стримить записи сразу в бд

### Шаг №3

В этом шаге решил сконцентрироваться на оптимизации загрузки страницы с рейсами

Импортировал данные из файла large.json в базу

#### 1.

Страница с рейсами загрузилась за 24158.2 ms
`bullet` сразу дал подсказку 'USE eager loading detected' для `app/views/trips/_trip.html.erb`

Результаты rack-mini-profiler так же указали на то, что здесь происходит очень много запросов на получении информации по каждому автобусу
```
Rendering: trips/index.html.erb	10686.2	+18.8	650 sql	1815.9
```

Добавил `includes([:bus])` в запрос на получение @trips

#### 2.

Дальше `bullet` стал жаловаться на такую же проблему N+1 и для `services`

Изменил запрос на получение @trips, чтобы дополнительно загружать еще и services:
```
@trips = Trip.preload(bus: :services).where(from: @from, to: @to).order(:start_time).load
```

После этого ActiveRecord больше не был главной точкой роста

Результаты rack-mini-profiler:
```
Rendering: trips/index.html.erb	6081.0	+2326.9	1 sql	9.3
```

Логи Rails:
```
Completed 200 OK in 17511ms (Views: 15219.8ms | ActiveRecord: 100.8ms)
```

#### 3.

По логам и результатам профилировщика rack-mini-profiler можно было заметить, что теперь основное время тратилось на загрузку вьюх

Решил избавиться от partials и перенести весь код из них в trips/index.html.erb
После изменений страница стала загружаться быстрее:
```
Completed 200 OK in 6027ms (Views: 3736.2ms | ActiveRecord: 56.0ms)
```

#### 4.

Нашел в trips/index.html.erb вызов count, заменил его на size
Время загрузки ActiveRecord изменилось в лучшую сторону:
```
Completed 200 OK in 6313ms (Views: 4103.4ms | ActiveRecord: 43.3ms)
```

#### 5.

Вернул обратно partials, но сделал их вызов с указанием коллекции
Это сделало код более читабельным, но при этом мы не потеряли в производительности

#### Результаты:

Загрузка страницы с расписанием:
|ДО                        |ПОСЛЕ                     |
|--------------------------|--------------------------|
| 24158.2 ms               | 6313.3 ms                |

#### Выводы

Страница с расписаниями стала намного быстрее загружаться, но 6 сек - это все равно очень большое время
Не думаю, что людям нужно сразу отображать всю информацию по расписанию, так как на странице загружается сразу 1004 рейса
В таком случае можно сделать пагинацию или последовательную загрузку данных по рейсам

### Шаг №4

В этом шаге решил обновить ruby и rails, чтобы посмотреть как измениться производительность

Обновил ruby с 2.6.3 до 3.2.2
Rails с 5.2.3 до ~> 6.0

#### Результаты

Импорт данных:
|                  |ДО                        |ПОСЛЕ ПЕРВОГО ШАГА        |ПОСЛЕ ОБНОВЛЕНИЯ RUBY |
|------------------|--------------------------|--------------------------|----------------------|
| example.json     | 0.547757 сек             | 0.257931 сек             | 0.221117 сек         |
| large.json       | очень долго              | 56 сек                   | 45.511732 сек        |
| medium.json      | 229 сек                  | 10 сек                   | 7.469367 сек         |
| small.json       | 30 сек                   | 2.990186 сек             | 2.487498 сек         |

Загрузка страницы с расписанием:
```
Completed 200 OK in 7124ms (Views: 5059.9ms | ActiveRecord: 39.5ms | Allocations: 6974902)
```

#### Выводы:

Не забывайте держать версию ruby в актуальном состоянии
Зачастую обновить язык - это один из самых эффективных способов повысить производительность

### Наблюдения

В рабочем проекте используем pghero как хороший инструмент для выявления медленных запросов, подсказок по индексам, занятой памяти
В этом проекте pghero показывает все зеленым. Пробовал делать много запросов - все равно его все устраивает.

#### Совет: как посчитать кол-во строк в файле
```
wc -l data_large.rb # (3250940)  total line count
```

#### Совет: как создать меньший файл из большего, оставив первые N строк
```
head -n N data_large.txt > dataN.txt
```

## Защита от регрессии производительности

Были написаны performace тесты на количество запросов в базу и скорость выполнения задачи