# Проблема с загрузкой json

Основная метрика - время обработки и загрузки в бд данных из json файла.
Выделил код для загрузки в сервис (просто для удобства), написал тест на регресс, и на быстродействие.
Тест использует данные небольшого размера, чтобы тесты проходили не очень долго, и прогресс быстродействия был измерим.
В первоначальном виде скрипт, загружающий данные, работает не более 20 секунд.
Это значение (20 сек) было выставлено в качестве нижнего порога для теста быстродействия.

Можно переходить к оптимизации.

#### Находка 1
- потратил некоторое время на профилирование скрипта с помощью ruby-prof. Но столкнулся с тем, что работа скрипта сильно замедлилась после включения профилировщика, и даже при обработке small.json я не мог дождаться окончания работы скрипта.
После уменьшения объема входных данных отчеты ruby-prof ничего интересного не показали: всю основную работу выполняет Active Record, при чем все последующие операции вложены друг в друга (я так понял так делается для возможности обеспечения транзакционности).
По отчетам я не смог точно определить, на какую именно операцию AR тратит больше всего времени, но видимо это частый коннект к базе данных, множество запросов поиска и вставки.
Было решено использовать гем active-record-import для оптимизации количества обращений к бд.
- переписал скрипт так, чтобы при обходе файла собирались массивы с объектами городов, автобусов, сервисов, трипов. После окончания обхода файла подгружаю поочередно каждую сущность с помощью гема activerecord-import.
- удалось уменьшить время выполнения скрипта для small.json с 20 секунд до 2 сек

#### Находка 2
- при запуске скрипта на large.json процесс убивается через некоторое время не отработав до конца.
Отчеты ruby-prof в режиме памяти показали, что слабым местом является вызовы Class.new.
- вместо создания объектов соответствующих моделей, сделал хеши.
- удалось уменьшить время выполнения скрипта для small.json с 2 секунд до 800 мс.
Теперь скрипт справляется с large.json и укладывается в 60 секунд.

# Проблема с рендером расписаний

Основная метрика - время загрузки страницы с расписаниями рейсов автобусов.
Написал тест, который проверяет что содержимое страницы после рендеринга соответствующего экшена не меняется.
Можно было также написать тест на время загрузки страницы используя например selenium, но на это не было времени.

Установил pghero, bullet, rack_mini_profiler.
На данных из файла small страница грузится достаточно быстро. Поэтому использовал medium.
Время загрузки страницы до оптимизации 18 секунд.

### Находка 1
#### Что показали профайлеры:
bullet показал проблему n+1 при рендеринге модели автобуса. Так как мы подгрузили в память только рейсы, которые содержат идентификаторы автобусов, то чтобы получить значение модели автобуса приходится делать отдельный запрос в базу при рендеринге каждого автобуса.

```
USE eager loading detected
rails-optimization-task3_1  |   Trip => [:bus]    
rails-optimization-task3_1  |   Add to your query: .includes([:bus])
rails-optimization-task3_1  | Call stack
rails-optimization-task3_1  |   /rails-optimization-task3/app/views/trips/_trip.html.erb:5
```

pghero тоже показал часто вызываемые запросы

```
SELECT  "buses".* FROM "buses" WHERE "buses"."id" = $1 LIMIT $2
```
98 раз. Это как раз тот запрос, на который ругается bullet. Запрос данных автобуса при рендеринге рейса.

```
SELECT "services".* FROM "services" INNER JOIN "buses_services" ON "services"."id" = "buses_services"."service_id" WHERE "buses_services"."bus_id" = $1
```
98 раз. Вызывается, там где на вьюхе проверяется есть ли у текущего автобуса сервисы

```
SELECT "services".* FROM "services" INNER JOIN "buses_services" ON "services"."id" = "buses_services"."service_id" WHERE "buses_services"."bus_id" = $1 ORDER BY "services"."name" ASC
```
87 раз. Достаем сервисы автобуса для рендеринга.

rack mini profiler показывает, что большую часть времени рендерится trips/index.html и что в это время выполняется 100+ sql запросов.

также explain запрос по рейсам показал

```
Trip.where(from: @from, to: @to).order(:start_time).explain
  
Trip Load (1.8ms)  SELECT "trips".* FROM "trips" WHERE "trips"."from_id" = $1 AND "trips"."to_id" = $2 ORDER BY "trips"."start_time" ASC  [["from_id", 10], ["to_id", 7]]
=> EXPLAIN for: SELECT "trips".* FROM "trips" WHERE "trips"."from_id" = $1 AND "trips"."to_id" = $2 ORDER BY "trips"."start_time" ASC [["from_id", 10], ["to_id", 7]]
                          QUERY PLAN
---------------------------------------------------------------
 Sort  (cost=237.16..237.40 rows=96 width=34)
   Sort Key: start_time
   ->  Seq Scan on trips  (cost=0.00..234.00 rows=96 width=34)
         Filter: ((from_id = 10) AND (to_id = 7))
```
что планировщик запроса использует перебор строк таблицы (Seq Scan) при фильтрации по городу. Поэтому необходимо добавить индексы.

#### Как оптимизировал

- Добавил в таблицу trips составной индекс [from_id, to_id]

план запроса стал таким

```
EXPLAIN for: SELECT "trips".* FROM "trips" WHERE "trips"."from_id" = $1 AND "trips"."to_id" = $2 ORDER BY "trips"."start_time" ASC [["from_id", 10], ["to_id", 7]]
                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Sort  (cost=98.07..98.31 rows=96 width=34)
   Sort Key: start_time
   ->  Bitmap Heap Scan on trips  (cost=5.27..94.91 rows=96 width=34)
         Recheck Cond: ((from_id = 10) AND (to_id = 7))
         ->  Bitmap Index Scan on index_trips_on_from_id_and_to_id  (cost=0.00..5.25 rows=96 width=0)
               Index Cond: ((from_id = 10) AND (to_id = 7))
```

теперь для фильтрации по городам используется индекс.

- Добавил предзагрузку автобусов и сервисов таким образом

```
Trip.preload(bus: :services).where(from: @from, to: @to).order(:start_time)
```

Rack mini profiler показал, что теперь вместо 100+ запросов выполняется только 8 запросов.

Pghero подтвердил, что множественные запросы ушли. Теперь по количеству запросов на первых местах системные.
Также pghero показал, что самым долгим запросом теперь является:

```
SELECT "buses_services".* FROM "buses_services" WHERE "buses_services"."bus_id" IN ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $80, $81, $82, $83, $84, $85, $86, $87, $88, $89, $90, $91, $92, $93, $94, $95, $96, $97, $98)
```
и посоветовал добавить индекс
 
```
CREATE INDEX CONCURRENTLY ON buses_services (bus_id)
```

- Последуем совету pghero и добавим индекс по bus_id в таблицу buses_services

В итоге этот запрос ушел из топа pghero по average.

#### Как изменилась метрика:
Страница грузится где-то 8 секунд.

### Находка 2
#### Что показали профайлеры:

Страница грузится по прежнему недостаточно быстро. Rack mini profile показывает, что основное время уходит на рендеринг частичных представлений.

#### Как оптимизировал
Вместо рендеринга частичных представлений переместил весь код в index.html.erb

#### Как изменилась метрика:
Страница грузится не более 2-х секунд.
На large данных страница грузится не более 9 секунд.

# Бонус

На бонусную часть к сожалению нет времени, возможно если успею закончить курс до дедлайна попробую выполнить этот челендж.
