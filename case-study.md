# Case-study оптимизации

## Актуальные проблемы

## Проблема №1
В нашем проекте возникла проблема. 

При увеличении объёма данных для импорта - слишком сильно увеличивается время работы скрипта 

Мы решили исправить эту проблему, оптимизировав данный скрипт

## Проблема №1: Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: при помощи benchmark замерять сколько необходимо времени для успешного завершения программы. 
При помощи профилировщика RubyProf оценить объём аллоцируемой памяти. И при помощи valgrind-massif оценить кол-во потребляемой скриптом памяти программы.

## Проблема №1: Гарантия корректности работы оптимизированной программы
Для оценки работоспособности программы необхожимо написать тесты, чтобы в фидбек-лупе не позволять изменение логики программы при оптимизации.

## Проблема №1: Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 15 сек

Вот как я построил `feedback_loop`:
1. Замерил с помощью benchmark сколько времени нужно программе для завершения работы
2. Замерил с помощью Ruby-Prof кол-во аллоцируемой памяти
3. Замерил при помощи valgrind-massif сколько памяти использует скрипт во время всей работы
4. Проанализировал метрики
5. Нашел главную точку роста
6. Оптимизировал точку роста
7. Получилось увеличить скорость? -> Commit. Не получилось увеличить или получили обратный эффект -> Revert

### Проблема №1: Находка №1
- Какой отчёт показал главную точку роста
- Бенчмарк показал, что скрипт на маленьких данных отрабатывает очень долго (33 сек). Проверил что происходит внутри при помощи Ruby-Prof flat графика, он показал что больше всего времени уходит на PG::Connection#exec_prepared(20.82%)
- Как вы решили её оптимизировать
Видимо нужно попытаться минимизировать запросы к БД, попытаюсь сделать это с помощью кэша
- Как изменилась метрика
Скрипт начал работать ровно в два раза быстрее: примерно 16.4 сек
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Да, точка роста перестала быть главной

### Проблема №1: Находка №2
- Какой отчёт показал главную точку роста
- Скрипт всё ещё очень медленно работает, нас это не устраивает и мы решили оптимизировать его дальше. RubyProf показал новую точку роста PG::Connection#exec_params (31.3%)
- Как вы решили её оптимизировать
Это видимо уже готовит параметры ActiveRecord. Нужно как-то пропустить этот момент.
- Как изменилась метрика
Заменил Trip.create на Trip.insert, помогло немного, метрика изменилась на 5-6% (15 сек)
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Нет, точка роста осталась главной

### Проблема №1: Находка №3
- Какой отчёт показал главную точку роста
- Копаю дальше, PG::Connection#exec_params уже (36.4%), 
видимо в прошлой итерации оптимизировалось что-то не то:) 
- Как вы решили её оптимизировать
Это видимо уже готовит параметры ActiveRecord. Нужно как-то пропустить этот момент.
- Как изменилась метрика
Заменил Trip.create на Trip.insert, помогло немного, метрика изменилась на 5-6% (15 сек)
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Нет, точка роста осталась главной

### Проблема №1: Находка №4
- Какой отчёт показал главную точку роста
- Всё так-же как в прошлом шаге
- Как вы решили её оптимизировать
- Создал модель BusesService и добавил таблице buses_services уникальный индекст по полям bus_id, service_id. Чтобы загружать сервисы при помощи upsert_all.
- Как изменилась метрика
- Скрипт стал работать быстрее на 50%, теперь файл загружается за 7.8 сек
Заменил Trip.create на Trip.insert, помогло немного, метрика изменилась на 5-6% (15 сек)
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Нет, точка роста осталась главной, теперь PG::Connection#exec_params занимает 29.72% времени

### Проблема №1: Находка №5
- Какой отчёт показал главную точку роста
- Всё так-же как в прошлом шаге
- Как вы решили её оптимизировать
- Заменил метод insert на insert_all при создании записей Trip
- Как изменилась метрика
- Теперь файл загружается за 6.2 сек
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Нет, точка роста осталась главной, теперь PG::Connection#exec_params занимает 30.49% времени

### Проблема №1: Находка №6
- Какой отчёт показал главную точку роста
- Всё так-же как в прошлом шаге
- Как вы решили её оптимизировать
- Решил как можно меньше использовать ActiveRecord. Добавил уникальные индексы в БД, чтобы проверять дополнительно уникальность по полям name. Так-же сделал 2 итерации по JSON данным. В первой мы собираем инфу о городах, автобусах и записываем их в БД. Во второй уже по путешествиям, сервисам и так-же пишем их в БД.
- Как изменилась метрика
- Теперь small файл загружается за 0.28 сек, а large за 7.1 сек. Тем самым в бюджет мы укладываемся, но ещё есть над чем работать, к примеру: оптимизировать программу по памяти.
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
Нет, точка роста осталась главной, теперь PG::Connection#exec_params занимает 16.35% времени

## Проблема №1: Результаты
Скорость работы скрипта до оптимизации: примерно 33 сек
После оптимизации: примерно 0.28 сек на small файле и 7.1 на large файле

## Проблема №1: Защита от регрессии производительности
-

## Проблема №2:
Время для открытия страницы `http://localhost:3000/%D0%B0%D0%B2%D1%82%D0%BE%D0%B1%D1%83%D1%81%D1%8B/%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B0/%D0%A1%D0%B0%D0%BC%D0%B0%D1%80%D0%B0` занимает огромное кол-во времени. Наши пользователи не долижаются загрузки страницы. Нужно срочно принять меры...

## Проблема №2: Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: при помощи rack-mini-profiler замерять сколько времени уходит на окончательную отрисовку страницы.

## Проблема №2: Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 15 сек

Вот как я построил `feedback_loop`:
1. Замерил с помощью rack-mini-profiler сколько времени нужно серверу для отрисовки страницы `/%D0%B0%D0%B2%D1%82%D0%BE%D0%B1%D1%83%D1%81%D1%8B/%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B0/%D0%A1%D0%B0%D0%BC%D0%B0%D1%80%D0%B0`
2. Проанализировал метрики при помощи rack-mini-profiler и rails-panel
3. Нашел главную точку роста
4. Оптимизировал точку роста
5. Получилось увеличить скорость? -> Commit. Не получилось увеличить или получили обратный эффект -> Revert

### Проблема №2: Находка №1
- Какой отчёт показал главную точку роста
- Rack-mini-profiler и Rails-panel показали, что уходит слишком много времени на рендер шаблонов (7 сек) и 10-11 секунд в целом. Чтобы отрисовать шаблон `trips/index.html.erb` необходимо 654 sql запросова. Видно, что у нас как минимум проблема с "n+1" запросами. Начну с этого
- Как вы решили её оптимизировать
- Добавил preload для загрузки ассоциаций в контроллере
- Как изменилась метрика
- Теперь страница загружается за 6 секунд.
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Нет, рендеринг остался таким-же, видимо дело в самих шаблонах. ActiveRecord теперь занимает 72 ms вместо 3 сек.

### Проблема №2: Находка №2
- Какой отчёт показал главную точку роста
- Rack-mini-profiler и Rails-panel показали, что уходит слишком много времени на рендер шаблонов (6 сек) секунд. 
- Как вы решили её оптимизировать
- Поиграться с рендерингом темплейта
- Как изменилась метрика
- Страница загружается примерно за 220 ms
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Для меня, если честно это оказалось ШОК-контентом, я даже не думал что вставка ERB шаблонов такая долгая... Мне кажется нужно смотреть и пытаться всё-таки оптимизировать это кешированием. Т.к если писать всё в одном шаблоне, то будет сложно поддерживать код... Точка роста - всё та-же, рендер...

### Проблема №2: Находка №3
- Какой отчёт показал главную точку роста
- Рендер, примерно 120-160 ms
- Как вы решили её оптимизировать
- Добавил редис и кеширование
- Как изменилась метрика
- Страница рендериться менее чем за 100 ms
- Как изменился отчёт профилировщика - исправленная проблема перестала быть главной точкой роста?
- Да, теперь рендер и activerecord примерно на одном уровне. Далее оптимизировать приложение не вижу смысла. Хотя есть над чем работать:
1. Добавить инвалидацию кеша
2. Сделать кэширование по принципу Russian Doll Caching
Позже вернусь к этому вопросу
