# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникли две серьёзные проблемы.

Я решил исправить эти проблемы, оптимизировав их.

- Нужно оптимизировать механизм перезагрузки расписания из файла.
- Нужно найти и устранить проблемы, замедляющие формирование этих страниц.

## Проблема 1: Импорт данных

### Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: *время полной обработки файла в секундах*

### Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *74 секунды*

Вот как я построил `feedback_loop`:
  1. Для проверки правильности отчета использовал минимальный набор данных `medium.json` (10K трипов).
  2. Использовал профилировщик или `pghero` для поиска точки роста
  3. Рефакторил код
  4. Повторно проверял результат
  5. В случае успешного результата делал коммит

Вот какие проблемы удалось найти и решить

#### Находка №1
- `pghero` - предложил создать несколько индексов.
- добавил индексы для `buses` и `trips`
- улучшилось на 5 сек, с 74 сек. => 69 сек.

#### Находка №2
- Решил переписать с использованием `activerecord-import`
- улучшилось очень круто, с 69 сек. => 7 сек.

### Результаты
В результате проделанной оптимизации наконец удалось обработать файл `large.json` (100K трипов) за *41 сек.* и уложиться в заданный бюджет.
Удалось улучшить метрику системы с *74 сек. до 3 сек* для `medium.json`.


## Проблема 2: Отображение расписаний

### Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: *время полной загрузки страницы*

### Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *6500 милисекунды*

Вот как я построил `feedback_loop`:
  1. Для проверки правильности отчета использовал минимальный набор данных `medium.json` (10K трипов).
  2. Использовал
    - rack-mini-profiler
    - bullet
    - rails panel
    - explain запросов
  3. Рефакторил код
  4. Повторно проверял результат
  5. В случае успешного результата делал коммит

Вот какие проблемы удалось найти и решить

#### Находка №1
- `gem bullet` обнаружил N + 1: `Add to your query: .includes([:bus]) and .includes([:services])`
- добавил `include(bus: :services)`
- исправленна проблема N + 1
- скорость отображения страницы изменилась с `65000 ms` до `26000 ms`

#### Находка №2
- По отчету pghero было видно, что в топе запрос
```
SELECT "services".* FROM "services" INNER JOIN "buses_services" ON "services"."id" = "buses_services"."service_id" WHERE "buses_services"."bus_id" = $1
```
- построив визуальное представление запроса видно, что 88% времени уходит на seq scan on buses_services 
- добавляю индекс на buses_services.bus_id в надежде, что теперь будет обращение исключительно к индексу
- Метрика не изменилась, из Explain ушел Seq Scan и сменился на Index Scan using index_buses_services_on_bus_id on buses_services

#### Находка №3
- Решил обратить внимание на ускорение рендеринга. На вкладке Rails panel было видно что много раз вызывается рендер маленького участка views/trips/_service.html.erb
- Решил переписать рендеринг.
- Общее время сократилось до 508ms, время ренедера по Rails Panel 443.1ms

### Результаты
В результате проделанной оптимизации наконец удалось обработать файл `large.json` (100K трипов) за *2676 ms* и уложиться в заданный бюджет.
Удалось улучшить метрику системы с *65 сек. до 508 ms* для `medium.json`.