# Case-study оптимизации

## Актуальная проблема

Необходимо импортировать файл с данными fixtures/large.json с 100_000 трипов менее чем за 1 минуту.

У нас уже была rake задача, которая умела делать нужную обработку.

Но она недостаточно производительна
Так:
 small.json с 1K трипов обрабатывается за 9 секунд
 medium.json с 10K трипов обрабатывается за 80 секунд

По грубым оценкам large.json с 100K трипов будет обрабатываться не менее 800 секунд.

## Формирование метрики
Для анализа влияния изменений на скорость работы возьмем время обработки файла small.json - 9 секунд  

## Гарантия корректности работы оптимизированной программы
Для проверки корректности работы обновленной программы был написан тест, который заполнял БД данными из файла example.json, потом выгружал БД в json и сравнивал с исходным.

## Feedback-Loop

1. Проверка корректности работы, замер метрики, сбор отчета
2. Изучение отчетов профайлеров

Например 
 rails test test/system/load_test.rb && rake reload_json"[fixtures/small.json]" &&  rake pghero:capture_query_stats

## Вникаем в детали системы, чтобы найти главные точки роста

Для того, чтобы найти "точки роста" для оптимизации я воспользовался
- pg_hero

Вот какие проблемы удалось найти и решить

### Находка №1
- pg_hero показал что запросы 
 ```SELECT "services".* FROM "services" INNER JOIN "buses_services" ON "services"."id" = "buses_services"."service_id" WHERE "buses_services"."bus_id" = $1```
 занимают 25% времени. explain показал последовательное чтение.
- добавить индекс ```:buses_services, [:bus_id, :service_id] ```
- значимого изменения метрики нет
- в отчете pg_hero запрос переместился с верхней строчки вниз

### Находка №2
- pg_hero показал что запросы ```SELECT  ? AS one FROM "buses" WHERE "buses"."number" = $1 AND "buses"."id" != $2 LIMIT $3``` занимают 23% времени 
- добавить индекс ```:buses, :number```
- метрика изменилась незначительно на 0.3 секунды
- в отчете pg_hero запрос переместился с верхней строчки вниз

### Находка №3
- pg_hero показал что запросы ```SELECT  "services".* FROM "services" WHERE "services"."name" = $1 LIMIT $2``` занимают 18% времени 
- принято решение заполнить все возможные сервисы предварительно и собрать в хеш и не запрашивать бд
- метрика снизилась примерно на 1,5 секунды до 7,2 секунд
- запрос исчез из отчета

### Находка №4
- pg_hero показал что запросы ```SELECT  "cities".* FROM "cities" WHERE "cities"."name" = $1 LIMIT $2``` занимают 12% времени 
- принято решение кешировать города в хеш
- метрика снизилась до 6 секунд
- запросы стал занимать менее 0.1% времени

### Находка №5
- pg_hero показал что запросы 
 ```SELECT "services".* FROM "services" INNER JOIN "buses_services" ON "services"."id" = "buses_services"."service_id" WHERE "buses_services"."bus_id" = $1```
 занимают 47% времени. 
- принято решение переписать поиск и заполнение автобуса
- метрика уменьшилась до 4,8 секунды  
- запрос исчез из отчета

### Протеситирована метрика время обработки medium.json - 21 секунда. Переходим на эту метрику

### Находка №6
- pg_hero показал что запросы 
   ```SELECT  "buses".* FROM "buses" WHERE "buses"."number" = $1 LIMIT $2``` занимают 33% времени
- принято решение кешировать автобусы аналогично городам
- метрика снизилась до 14 секунд
- запрос исчез из отчета

### Находка №7
- pg_hero показал что запросы вставки в таблицу trip занимают 40% времени
- вставлять записи пачками  
- ничего не изменилось, потому что activerecord запрограммирован вставлять по одной

### Находка №8
- Существует гем activerecord-import, который позволяет вставлять записи пачками
- применить гем
- метрика уменьшилась до 7 секунд
- запросы вставки в таблицу trips самые емкие по времени, но с этим ничего не поделать

## Результаты
В результате проделанной оптимизации удалось обработать файл с данными за заданое время. Сейчас оно составляет 22 секунды. 

###Какими ещё результами можете поделиться
1. Гем activerecord-import выполняет вставку без валидации записей. Его использование приносит дополнительный риск. 
1. В rails 6 в классе ActiveRecord есть метод insert_all. Имеет те же недостатки. 
1. 
```
rake reload_json"[1M.json]"
   ActiveRecord::RecordInvalid: Validation failed: Name has spaces
```



## Защита от регрессии производительности

Для защиты от потери достигнутого прогресса при дальнейших изменениях программы был написан тест ...

