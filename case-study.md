*Case-study оптимизации*

## Импорт

В качестве метрик оптимизации было время выполнения импорта файла small.json.
Текущее значение метрики: 5 сек.

### Находка 1:
  - в топе pghero запрос
  `SELECT "services".* FROM "services" INNER JOIN "buses_services" ON "services"."id" = "buses_services"."service_id" WHERE "buses_services"."bus_id" = $1`, вызывается в строке `bus.update(model: trip['bus']['model'], services: services)`
  - Вынесем создание buses_services из цикла, а также уберем лишний update для bus
  - Метрика сократилась до 2.87 сек (память: 104 MB), точка роста изменилась

### Находка 2:
  - в топе pghero запрос
  `SELECT  "buses"`, вызывается в строке `bus = Bus.find_or_initialize_by(number: attrs['number'])`
  - Добавим рекомендованный индекс на колонку, а также поменяем тип колонки на integer
  - Метрика незначительно сократилась до 2.81 сек (память: 102 MB), точка роста изменилась

### Находка 3:
  - в топе pghero запрос
  `SELECT  "services"`, вызывается в строке `Service.find_or_create_by(name: service_name)`
  - Т.к сервисов весьма ограниченное количество и имена их известны - мы можем создать их заранее и исключить проверку из цикла
  - Метрика сократилась до 1.8 сек (память: 102 MB), точка роста изменилась

### Находка 4:
  - в топе pghero запросы `SELECT  "cities"` и `INSERT INTO "trips"`.
  - Попробуем вынести создание cities и trips из цикла
  - Метрика сократилась до 0.56 сек (память 107 MB), точка роста изменилась

### Находка 5:
  - в топе pghero запрос `INSERT INTO "buses"`.
  - Попробуем создавать buses отдельной операцией. Для этого нужно поменять foreign_key с bus_id на bus_number.
    Т.к поле все равно уникальное и того же типа - проблем с перформансом быть не должно (только с читаемостью кода)
  - Метрика сократилась до 0.25 сек (память 110 MB), точка роста изменилась на insert.

### Заключение
  Время обработки файла large 8-10 сек, что укладывается в метрику с большим запасом. Потребление памяти: 460 mb
  Время обработки файла 1M ~ 100сек. Дальнейшая оптимизация требует радикальной переработки (потоковая запись),
  к сожалению на это сейчас нет времени. Но тем не менее результат уже неплохой.


## Загрузка страницы

В качестве метрик оптимизации было время загрузки страницы списка.
Текущее значение метрики: 8379 мс. (Память 124мб)

### Находка 1:
  - bullet показал eager loading `Trip => [:bus]`
  - Последуем рекомендации и добавим загрузку
  - Метрика сократилась до 6189 мс.

### Находка 2:
  - bullet показал eager loading `Bus => [:buses_services]` и `Bus => [:services]`
  - Последуем рекомендации и добавим загрузку
  - Метрика выросла до 8361, bullet warning пропал.
    Отключение bullet снизило время загрузки до 4081 мс, пока продолжим работать с этим значением

### Находка 3:
  - rack-mini-profiler показал точку роста в `trips/index.html.erb`, запрос на получение trips.
  - Добавим многоколоночный индекс на таблицу trips, для полей `from_id` и `to_id`
  - Метрика сократилась до 3582 мс.

### Находка 4:
  - rack-mini-profiler показал точку роста в `trips/index.html.erb`, запрос на получение buses и buses_services.
  - Добавим индекс для buses_services
  - Метрика незначительно сократилась до 3233 мс.

### Находка 5:
  - rack-mini-profiler показал, что основная часть времени тратится на рендеринг.
  - Попробуем переработать паршлы
  - Метрика сократилась до 600 мс.

### Заключение
  Время загрузки страницы ~600мс, для такого объема данных вполне приемлемо. Добавление пагинации невилирует проблему совсем.
