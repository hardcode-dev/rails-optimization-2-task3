# Case-study оптимизации

## Актуальная проблема
Оптимизация rails приложения

1. Медленная загрузка изначальных данных
2. Не оптимальная работа приложения по выводу информации

## Формирование метрики
Для первой части задания метрикой является время загрузка в БД изначальных данных
Бюджет метрики - large файл с данными должен загружаться быстрее минуты

Для второй части необходимо провести оптимизацию вывод информации
После загрузки данных был произведен просмотр страницы

результаты времени выполнение для large данных
Rendered trips/index.html.erb within layouts/application (3082.9ms)
Completed 200 OK in 3703ms (Views: 3358.3ms | ActiveRecord: 302.6ms)

## Feedback-Loop
Вот как я построил `feedback_loop` для проверки загрузки данных:
т.к. идея на данном этапе понятна - это использовать activerecord-import и делать как можно меньше запросов, то:
- проверить время загрузки
- внести изменения в алгоритм
- повторить

`feedback_loop` для оптимизации вывода информации:
- предварительная проверка через bullet
- цикличная проверка через PgHero
  - поиск точки роста
  - модификация (добавление индексов, оптимизация запросов)
  - проверка результата
  - повторение

## Находка 1
Раздумия над алгоритмом загрузки показали, что:
- должно быть слишком много запросов на создание/поиск городов, т.к. их всего 10, то проще и быстрее создать их за 1 прозод через файл, сформировать список загруженных и затем использовать его вместо постоянного обращения к БД
- с сервисами такая же проблема, к тому же в описании задания сказано, что их всегда 10, можно заранее загрузить
- для загрузки автобусов и маршрутов использовать activerecord-import с подставлением заранее загруженных данных по городам и сервисам
- в БД нет индексов, поэтому загрузка данных будет максимально быстрой
- добавил валидацию на уникальность для сервисов по названию (особо не имеет смысла, если сервисов всегда 10 и они не меняются, но пусть будет)

### Решение 1
- гипотеза: использовать activerecord-import,
- применение: сперва переделал алгоритм загрузка с использованием гема, в итоге время загрузка small файла уменьшилось, но даже medium файл загружается больше минуты

### Решение 2
- гипотеза: проходить через json несколько раз, с загрузкой части данных
- применение:
  - во время первого прохода через json формируются массивы для городов и сервисов, затем список городов формируется в хэш, { название => айди }, для загрузки путешествий нужен будет только айди города, сервисы - { название => объект }, т.к. для создания записей через has_and_belongs_to_many для автобусов нужно будет передавать массив объектов
  - во время второго прохода формируется список автобусов, для сервисов используются заранее загруженные данные
  - для городов и автобусов - данные формируются через результат работы гема, без доп запросов в БД
  - при третьем проходе формируются маршруты
- результат
  - medium файл стал загружаться за 7 секнуд
  - large - 23 секунды

### Решение 3
- вспомнил, что сервисы постоянны
- применение:
  - сервисы создаются заранее, без прозода по массиву данных
  - на первом проходе через данные теперь формируется список городов и автобусов
  - на втором проходе - формируются маршруты
результат
  - время обработки визуально не изменилось, но должно быть чуточку быстрее, особенно на гигантских данных
  - последние данные по времени загрузки - 22 секунды

## Находка 2
- сообщение от bullet
USE eager loading detected
  Trip => [:bus]
  Add to your query: .includes([:bus])

- добавил .includes(:bus)
- сообщение от bullet
USE eager loading detected
  Bus => [:services]
  Add to your query: .includes([:services])
- изменил на .includes(bus: :services)
- результат:
  - выполняется всего 6 запросов в БД
  - много рендеринга паршиалов
  - загрузка из БД ускорилась в 10 раз
  - рендеринг в 2 раза
Rendered trips/index.html.erb within layouts/application (1825.6ms)
Completed 200 OK in 1862ms (Views: 1802.2ms | ActiveRecord: 38.3ms)

## Находка 3
- теперь пора добавлять индексы для поиска
  - для поиска города по имени
  - для поиска маршрутов по двум полям, from/to, составной
  - для маршрутов отдельные индексы для bus_id и для start_time
  - составной индекс для таблицы buses_services

Результаты PgHero (после внесение изменений в конфиг pg, для сбора статистики)
No long running queries
Connections healthy 7
Vacuuming healthy
No columns near integer overflow
No invalid indexes or constraints
No duplicate indexes
No slow queries

Space вкладка
- индексы для bus_id и start_time в trips бесполезные, надо удалить

Queries вкладка
- основные запросы - на создание индексов и какие-то рельсовые
- запросы для улучшения
  - 8 мс 4 раза - получение маршрутов
  - 8 мс 4 раза - подсчет count для маршрутов (изменить на size, думаю лишний запрос)
  - остальное незначительно

результат:
  - загрузка из БД ускорилась в 3 раза, общее ускорение БД - 30 раз
Rendered trips/index.html.erb within layouts/application (1771.6ms)
Completed 200 OK in 1784ms (Views: 1769.6ms | ActiveRecord: 12.7ms)

## Находка 4
ПРОБЛЕМА
- обнаружил, что не создались записи для связанной таблицы buses_services
- решение исправил файл загрузки + создал класс BusesService для запуска импорта
- результат: время загрузки уменьшилось до 20 секунд
  - видимо автобусы стали быстрее загружаться без дополнительных данных, а загрузка связанной таблицы занимает меньше времени

Рендеринг с сервисами из БД
Rendered trips/index.html.erb within layouts/application (4275.7ms)
Completed 200 OK in 4299ms (Views: 4262.1ms | ActiveRecord: 28.4ms)

Рендеринг без сервисов
Rendered trips/index.html.erb within layouts/application (841.3ms)
Completed 200 OK in 854ms (Views: 836.4ms | ActiveRecord: 15.7ms)

Видно, что значительное время тратится на рендеринг названий сервисов для автобусов
имеет смысл сделать сервисы статичными без использования БД и хранить их прямо в автобусах, а при изменении сервиса вызывать обновление всех связанных автобусов
