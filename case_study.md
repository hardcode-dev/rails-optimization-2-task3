## Задача - оптимизировать rake reload_json[fixtures/large.json] так, чтобы он выполнялся менее, чем за 60 секунд.

Сейчас он выполняется за 2452.57 секунд

Посмотрим, что покаже профилировщик callgrind, но 40 минут ждать наверное чересчур долго, поэтому прогоним файл medium, судя по размеру, он примерно в 10 раз меньше large. 

Не оптимизированная версия
Start
Finish in 127.63
Finish in 129.48

После первой итерации (только Trips завернули в import)
Finish in 116.12

### Защитимся от внесения функциональных ошибок тестом test/services/reload_json_spec.rb

### Первая гипотеза
#### Использование библиотеки active_record_import
Подпилил код так, чтоб запись в базу данных производилась только тремя транзакциями при помощи active_record_import библиотеки. Но теперь столкнулся с багом 
Users/ruslan/.rbenv/versions/2.6.3/lib/ruby/gems/2.6.0/gems/activesupport-5.2.4.1/lib/active_support/callbacks.rb:425: [BUG] object allocation during garbage collection phase

На форумах пишут, что это может быть из-за слишком большого объема аллоцированной памяти. 
После перезагрузки получлиось прогнать скрипт, но результат с файлом large получился неутешительным

Start
Finish in 963.89

запустим профилировщик на файле medium, отчет 15884 показывает, что всего потребляется времени 435_981_521
BenchmarkEvaluation показывает Finish in 92.72

### Вторая гипотеза
#### Попробуем в транзакцию обернуть не все действо само по себе, а только обращения к базе данных.

Теперь BenchmarkEvaluation показывает Finish in 31.51, запустим профилировщик

Судя по трейсу, мы очень много времени тратим на выгрузку всех City после того, как сохраняем автобусы с рекукрсией. Думаю, причина в том, что эта рекурсия, пытаясь сохранить trips подгружает зачем-то все from и to для какждой конкретной поездки. Возможно, если по аналогии с сервисами и автобусами складывать все созданные trips-ы в один массив а потом одной дополнительной транзакцией сохранять в бд, то этой излишней подзагрузки Cities можно будет избежать. 

PG hero показывает, что хоть и время на один такой вызов - 0 ms, мы имеем 80 тысяч вызовов, и по итогу - 39% в Total Time. Значит, будем к этому относиться как к главной точке роста. Попробуем проверить мою гипотезу с отменой рекурсии на сохранении автобусов. Если отменить рекурсию, то new_trip не узнает о том, что его bus получил айдишник, и при попытке сохраниться в базу, получит ошибку валидации. Но если сперва импортировать автобусы, а потом cities, то new_trip по итогу тоже сохраняется в базу. 

### Третья гипотеза
#### Поменять очередность импорта данных
Сперва импортируем автобусы, потом уже города. Судя по экспериментам в консоли, Trip при этом тоже сохраняется.
Посмотрим, не появится ли N+1 запросов при импорте всего файла.

BenchmarkEvaluation показал, что гипотеза оправдалась. N+1 запросов не было, а время выполнения снизилось до Finish in 19.99 секунд. 
Отчет callgrind 22862 показывает, что total_wall_time снизилось до 78_003_757, то есть более чем в 5 раз по сравнению с тем, когда все вычисление было в транзакции, и почти в 3 раза по сравнению с последней итерацией.

Однако large.json файл парсится за Finish in 216.13, что более чем втрое превышает бюджет.

Думаю, можно разделить выполнение сервиса на две части - 1) сам парсинг json, и 2) запись результатов в бд. Чтобы понять, что оптимизировать.

Итак, без записи в базу данных large.json парсится за 
Finish in 56.77 секунд
Отчет callgrind 24651

Судя по отчетам callgrind, больше 30% времени тратится на чтение и запись аттрибутов модели. Но учитывая, что мы импортируем ассоциации, связанные между собой, вряд ли от этого можно отказаться. Теоретически, можно попробовать смоделировать своего рода мини бд, и присваивать моделям заранее заготовленные айдишники, ведь вначале транзакции мы все равно всех удаляем. Но этот костыль может сгодится только для seed данных, когда все индексы в базе инициализируются с самого начала. 

Попробуем для интереса удалить инструкции на случай конфликтов, потому что уникальность импортируемых сущностей мы проверяем еще в скрипте. Как это повлияет на скорость выполнения.

### Четвертая гипотеза
#### Отменить инструкции на случай конфликтов при импорте. 
Практически никак не повлияло. Отчеты аналогичны предыдущим.

В Slack'е посоветовали вчера все-таки реализовать идею с ранним присвоением айдишников. Думаю, в рамках задания это приемлемо. 

### Пятая гипотеза
#### Присваивать айдишники на уровне скрипта, и импортировать в базу данных сущности нерекурсивно.

Вдобавок ко всему, сделаем это, отказавщись от хэшей, используя только массивы (за исключением json-а)

Результат оказался очень впечатляющим.
Finish in 2.4 для medium файла
Finish in 28.38 для large файла, что вдвое лучше, чем желаемый бюджет.

## Задача - Оптимизировать загрузку расписания 
Для примера возьмем страницу расписания Ростов-Москва

Загружается страница за 22 секунды.

Completed 200 OK in 22414ms (Views: 21465.9ms | ActiveRecord: 921.7ms)

Библиотека bullet показывает, что можно оптимизировать загрузку сущностей во вьюхах

`
  USE eager loading detected
    Trip => [:bus]
    Add to your query: .includes([:bus])
  Call stack
    /Users/ruslan/thinknetica/rails-optimization-task3/app/views/trips/_trip.html.erb:5:in _app_views_trips__trip_html_erb__4123366501770329106_70122052014260'
    /Users/ruslan/thinknetica/rails-optimization-task3/app/views/trips/index.html.erb:10:in block in _app_views_trips_index_html_erb__3093244103436595714_70122040798380'
    /Users/ruslan/thinknetica/rails-optimization-task3/app/views/trips/index.html.erb:8:in _app_views_trips_index_html_erb__3093244103436595714_70122040798380'
`

Попробуем выполнить эту рекомендацию

### Первая гипотеза
#### Добавить .includes(:bus) в загрузку Trip-ов

В trips_controller поменял 
  `Trip.where(from: @from, to: @to).order(:start_time)`
на 
  `Trip.includes(:bus).where(from: @from, to: @to).order(:start_time)`

Completed 200 OK in 18741ms (Views: 17893.4ms | ActiveRecord: 828.2ms)

Теперь bullet показывает
  
`
  user: ruslan
  USE eager loading detected
    Bus => [:buses_services]
    Add to your query: .includes([:buses_services])
  Call stack
    /Users/ruslan/thinknetica/rails-optimization-task3/app/views/trips/index.html.erb:11:in block in _app_views_trips_index_html_erb__3093244103436595714_70122025574360'
    /Users/ruslan/thinknetica/rails-optimization-task3/app/views/trips/index.html.erb:8:in _app_views_trips_index_html_erb__3093244103436595714_70122025574360'
`

### Вторая гипотеза
#### Добавить .includes(bus: [:buses_services]) в загрузку Trip-ов

В trips_controller поменял 
  `Trip.includes(:bus).where(from: @from, to: @to).order(:start_time)`
на 
  `Trip.includes(bus: [:buses_services]).where(from: @from, to: @to).order(:start_time)`

Completed 200 OK in 16043ms (Views: 15232.7ms | ActiveRecord: 765.1ms)

Теперь bullet показывает

`
  user: ruslan
  USE eager loading detected
  Bus => [:services]
  Add to your query: .includes([:services])
  Call stack
  /Users/ruslan/thinknetica/rails-optimization-task3/app/views/trips/index.html.erb:11:in block in _app_views_trips_index_html_erb__3093244103436595714_70122070389780'
  /Users/ruslan/thinknetica/rails-optimization-task3/app/views/trips/index.html.erb:8:in _app_views_trips_index_html_erb__3093244103436595714_70122070389780'
`


### Третья гипотеза
#### Добавить .includes(bus: [:buses_services, :services]) в загрузку Trip-ов

Trip.includes(bus: [:buses_services, :services]).where(from: @from, to: @to).order(:start_time)

Completed 200 OK in 15043ms (Views: 14981.3ms | ActiveRecord: 46.3ms)

Однако после добавления bullet все равно выводит то же самое сообщение.

Как мы видим, ActiveRecord загружается за 46.3ms, а вот вьюхи грузятся, по-прежнему, долго

Rack-mini profiler показывает то же самое

По итогу, оставил includes(bus: [:services]), судя по логам, в производительности мы не потеряли.

Суммарно при переходе на страницу делается 8 запросов к базе и тратится на них меньше 130ms.
 А вот Rendering: trips/index после этого повторяется многократно.

Rails Panel тоже показывает аналогичные расходы:
ActiveRecord        63ms
Other               30ms 
Rendering           13_056ms

### Четвертая гипотеза
#### Убрать рендеринг всех паршалов из вьюхи trips/index.html.erb

Теперь время загрузки выглядит так

В логах
Completed 200 OK in 8512ms (Views: 8441.0ms | ActiveRecord: 58.1ms)

В Rails Panel
ActiveRecord        58ms
Other               12ms
Rendering           8_441ms


В логах можно заметить, что к базе мы обращаемся два раза за время загрузки index вьюхи, первый раз - в пятой строке, второй раз - восьмой.
И в пятой строке обнаруживается применение метода count, который, как мы знаем, очень нехорош, и лучше бы его заменить size. А коллекцию, возможно загрузить с помощью load

### Пятая гипотеза
#### Заменить во вьюхе trips/index.html.erb `count` на `load.size`


Rendered trips/index.html.erb within layouts/application (8723.6ms)
Completed 200 OK in 8758ms (Views: 8690.7ms | ActiveRecord: 52.7ms)

Особо эффекта на результат не возымело, даже на полсекунды дольше стало загружаться, но по логам видно, что в 8 строке загрузка все этих сущностей идет уже из кэша за время 0.0ms, так что это решение оставим как есть.

Во вьюхе в графе "Прибытие" Видим применеине метода Time.parse, а с первого ДЗ я помню, что это не быстрый метод. Попробуем применить вместо него метод to_time.

### Шестая гипотеза
#### Заменить во вьюхе trips/index.html.erb `Time.parse` на `to_time`

В результате

Completed 200 OK in 8136ms (Views: 8096.6ms | ActiveRecord: 28.5ms)


Можно попробовать эти строковые значения, которые вычисляются во вьюхах, вычислять при помощи коллбэков перед сохранением в бд, и тогда вьюхе надо будет просто рендерить поле, но сперва поймем, какой профит это даст. Заменим все вычисляемые поля на просто поля, без оглядки на корректность вьюхи, и оценим время загрузки.

### Седьмая гипотеза
#### Убрать все вычисления во вьюхе trips/index.html.erb

Никакого профита, первый раз страница загрузилась даже за 9+ секунд. Так что геморрой с костылями и колбэками себя не оправдывает.


Лучшее - враг хорошего, загрузку вьюхи нам удалось ускорить почти в три раза, самый быстрый результат был быстрее, чем 8 секунд, тогда как изначально это больше 22 секунд. 


































