# Case-study оптимизации B

## Актуальная проблема
Нужно найти и устранить проблемы, замедляющие формирование страницы расписаний.

`open http://localhost:3000/автобусы/Самара/Москва`

Я решил исправить эту проблему, оптимизировав модели, связи между ними и обращения к БД.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время загрузки веб-страницы после предварительного импорта файла с данными large.json.

## Гарантия корректности работы оптимизированной программы
Результат работы страницы `автобусы/Самара/Москва` для данных из файла `fixtures/example.json` не должен меняться от применения оптимизаций.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы, я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за меньшее 10 секунд время.

Вот как я построил `feedback_loop`: благодаря подключению профилирующих плагинов, стало возможным видеть многие очевидные проблемы во всплывающих окнах поверх самой загруженной страницы с расписанием автобусов.
С этого момента наш feedback loop создан, и мы можем переходить к профилированию и изменению кода, после чего загружать страницу повторно для сравнения результатов с отправным шагом (или шагом предыдущей итерации).

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался инструментами `rack-mini-profiler`, `rails panel`, `bullet`, `pghero`.

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- какой отчёт показал главную точку роста
  * `rack-mini-profiler` указал время загрузки страницы до начала оптимизаций около 9 секунд. `rails panel` привел разбивку этого времени по обращениям к БД и собственно рендерингу. В данном случае рендеринг занимал большую часть времени - порядка 6,7 секунды. На вкладке Rendering видно, что ответственный за это время - файл `views/trips/index.html.erb`: `Rendering: trips/index.html.erb	3812.2	+13.5	768 sql	573.9`. Это и будет основная точка роста.
- как вы решили её оптимизировать
  * Важно изменить код в темплейте так, чтобы уменьшить число запросов к базе данных. По подсказке `bullet` я добавил в `trips_controller` предзагрузку связанных с trips записей: `.preload(bus: :services)`
- как изменилась метрика
  * время загрузки страницы сократилось до ~ 8 секунд. `Rendering: trips/index.html.erb	2673.6	+106.5	12 sql	45.9`
- как изменился отчёт профилировщика
  * предупреждения об отсутствующих предзагрузках пропали.

### Ваша находка №2
- какой отчёт показал главную точку роста
  * `rails panel` по-прежнему подчеркивает, что основное время загрузки страницы уходит на рендеринг. Особенно наглядно это видно в длинном списке вызовов отдельных темплейтов в логе Rails сервера.
- как вы решили её оптимизировать
  * Я решил сократить число вызовов различных partials и свести к минимуму количество темплейтов, которые нужно отрендерить. Для этого я использовал рендеринг коллекций и параметр шаблона разделителя. Одновременно было возможным оптимизировать "верхний" запрос к БД по метрикам `pghero`, который был отображен как самый долгий из текущих при рендеринге страницы:
  `SELECT COUNT(*) FROM "trips" WHERE "trips"."from_id" = $1 AND "trips"."to_id" = $2` 13ms average +
  `SELECT "trips".* FROM "trips" WHERE "trips"."from_id" = $1 AND "trips"."to_id" = $2 ORDER BY "trips"."start_time" ASC` 10ms average. Причиной был Seqential Scan on trips, получилось нивелировать это добавлением индекса.
- как изменилась метрика
  * время загрузки страницы сократилось до ~ 2.7 секунды
- как изменился отчёт профилировщика
  * ```
    GET http://localhost:3000/%D0%B0%D0%B2%D1%82%...	598.3	+0.0	1 sql	0.4
    Executing: trips#index	16.4	+4.0	2 sql	0.5
    Rendering: trips/index.html.erb	2071.4	+16.6	5 sql	9.6
    ```

## Результаты
В результате проделанной оптимизации удалось существенно снизить время загрузки страницы с информацией обо всех поездках. Метрика системы снизилась с 9 до 2.7 секунды.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях скрипта тесты на производительность алгоритма были зафиксированы на новых значениях, достигнутых за счет оптимизации.
